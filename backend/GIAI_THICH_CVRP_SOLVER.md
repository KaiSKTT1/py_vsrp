# üìö GI·∫¢I TH√çCH CHI TI·∫æT CVRP SOLVER API

## üéØ T·ªïng quan
File `cvrp_solver_api.py` ch·ª©a c√°c h√†m gi·∫£i quy·∫øt b√†i to√°n **CVRP (Capacitated Vehicle Routing Problem)** - B√†i to√°n ƒë·ªãnh tuy·∫øn xe c√≥ gi·ªõi h·∫°n t·∫£i tr·ªçng.

**M·ª•c ƒë√≠ch:** T·ªëi ∆∞u h√≥a vi·ªác ph√¢n b·ªï c√°c ƒëi·ªÉm giao h√†ng cho nhi·ªÅu xe, sao cho:
- ‚úÖ M·ªói ƒëi·ªÉm ƒë∆∞·ª£c gh√© ƒë√∫ng 1 l·∫ßn
- ‚úÖ T·∫£i tr·ªçng m·ªói xe kh√¥ng v∆∞·ª£t qu√° gi·ªõi h·∫°n
- ‚úÖ T·ªïng qu√£ng ƒë∆∞·ªùng ƒëi l√† ng·∫Øn nh·∫•t

---

## üìä C√ÅC H√ÄM CH√çNH

### 1Ô∏è‚É£ `compute_euclidean_distance_matrix(locations)`

**M·ª•c ƒë√≠ch:** T√≠nh ma tr·∫≠n kho·∫£ng c√°ch Euclidean (ƒë∆∞·ªùng chim bay) cho b√†i to√°n CVRP tr√™n m·∫∑t ph·∫≥ng 2D.

**Input:**
- `locations`: List c√°c ƒëi·ªÉm d·∫°ng `[[x1, y1], [x2, y2], ...]`

**Output:**
- Ma tr·∫≠n kho·∫£ng c√°ch 2D, `dist[i][j]` = kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm i ƒë·∫øn ƒëi·ªÉm j

**C√¥ng th·ª©c:**
```
distance = sqrt((x2 - x1)¬≤ + (y2 - y1)¬≤)
```

**S·ª≠ d·ª•ng `math.hypot()`:** H√†m n√†y t√≠nh c·∫°nh huy·ªÅn c·ªßa tam gi√°c vu√¥ng, t∆∞∆°ng ƒë∆∞∆°ng c√¥ng th·ª©c tr√™n nh∆∞ng ch√≠nh x√°c v√† nhanh h∆°n.

**V√≠ d·ª•:**
```python
locations = [[0, 0], [3, 4], [6, 8]]
# Kho·∫£ng c√°ch t·ª´ [0,0] ƒë·∫øn [3,4] = sqrt(3¬≤ + 4¬≤) = 5
```

**C√¢u h·ªèi th·∫ßy c√≥ th·ªÉ h·ªèi:**
- **Q: T·∫°i sao d√πng Euclidean?**
  - A: V√¨ ƒë√¢y l√† b√†i to√°n tr√™n m·∫∑t ph·∫≥ng t·ªça ƒë·ªô (x, y), kh√¥ng ph·∫£i GPS th·ª±c t·∫ø.
  
- **Q: T·∫°i sao chuy·ªÉn sang `int`?**
  - A: OR-Tools y√™u c·∫ßu ma tr·∫≠n kho·∫£ng c√°ch l√† s·ªë nguy√™n ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t t√≠nh to√°n.

---

### 2Ô∏è‚É£ `haversine_distance(lat1, lng1, lat2, lng2)`

**M·ª•c ƒë√≠ch:** T√≠nh kho·∫£ng c√°ch th·ª±c t·∫ø gi·ªØa 2 ƒëi·ªÉm GPS tr√™n b·ªÅ m·∫∑t Tr√°i ƒê·∫•t (ƒë∆°n v·ªã: m√©t).

**Input:**
- `lat1, lng1`: Vƒ© ƒë·ªô, kinh ƒë·ªô ƒëi·ªÉm 1
- `lat2, lng2`: Vƒ© ƒë·ªô, kinh ƒë·ªô ƒëi·ªÉm 2

**Output:**
- Kho·∫£ng c√°ch theo ƒë∆∞·ªùng cong Tr√°i ƒê·∫•t (m√©t)

**C√¥ng th·ª©c Haversine:**
```python
R = 6,371,000m  # B√°n k√≠nh Tr√°i ƒê·∫•t
œÜ1 = lat1 (radian)
œÜ2 = lat2 (radian)
ŒîœÜ = (lat2 - lat1) (radian)
ŒîŒª = (lng2 - lng1) (radian)

a = sin¬≤(ŒîœÜ/2) + cos(œÜ1) √ó cos(œÜ2) √ó sin¬≤(ŒîŒª/2)
c = 2 √ó atan2(‚àöa, ‚àö(1-a))
distance = R √ó c
```

**T·∫°i sao c·∫ßn Haversine?**
- Tr√°i ƒê·∫•t l√† h√¨nh c·∫ßu, kh√¥ng ph·∫£i m·∫∑t ph·∫≥ng
- C√¥ng th·ª©c Euclidean sai l·ªách l·ªõn v·ªõi GPS th·ª±c t·∫ø
- Haversine cho k·∫øt qu·∫£ ch√≠nh x√°c ~99.5%

**V√≠ d·ª• th·ª±c t·∫ø:**
```python
# T·ª´ H√† N·ªôi (21.0285, 105.8542) ƒë·∫øn TP.HCM (10.8231, 106.6297)
distance = haversine_distance(21.0285, 105.8542, 10.8231, 106.6297)
# K·∫øt qu·∫£: ~1,166,000m = 1,166 km
```

**C√¢u h·ªèi th·∫ßy c√≥ th·ªÉ h·ªèi:**
- **Q: T·∫°i sao kh√¥ng d√πng API Google Maps?**
  - A: API t·ªën ph√≠, gi·ªõi h·∫°n s·ªë l∆∞·ª£ng request, v√† kh√¥ng c·∫ßn thi·∫øt cho b√†i to√°n t·ªëi ∆∞u. Haversine ƒë·ªß ch√≠nh x√°c cho CVRP v·ªõi r√†ng bu·ªôc kh·ªëi l∆∞·ª£ng.

- **Q: Sai s·ªë bao nhi√™u so v·ªõi ƒë∆∞·ªùng th·ª±c t·∫ø?**
  - A: Haversine t√≠nh ƒë∆∞·ªùng chim bay, sai s·ªë ~10-15% so v·ªõi ƒë∆∞·ªùng ƒëi th·ª±c t·∫ø (c√≥ kh√∫c cua, ƒë√®o d·ªëc). Nh∆∞ng t·ª∑ l·ªá n√†y ƒë·ªìng ƒë·ªÅu n√™n kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn t·ªëi ∆∞u.

---

### 3Ô∏è‚É£ `compute_haversine_distance_matrix(locations)`

**M·ª•c ƒë√≠ch:** T·∫°o ma tr·∫≠n kho·∫£ng c√°ch cho T·∫§T C·∫¢ c√°c c·∫∑p ƒëi·ªÉm GPS.

**Input:**
- `locations`: List c√°c ƒëi·ªÉm GPS `[[lat1, lng1], [lat2, lng2], ...]`

**Output:**
- Ma tr·∫≠n 2D, `dist[i][j]` = kho·∫£ng c√°ch Haversine t·ª´ i ƒë·∫øn j

**C√°ch ho·∫°t ƒë·ªông:**
```python
# V·ªõi 3 ƒëi·ªÉm A, B, C, t·∫°o ma tr·∫≠n:
#     A    B    C
# A [ 0,  d_AB, d_AC ]
# B [d_BA,  0,  d_BC ]
# C [d_CA, d_CB,  0  ]
```

**ƒê·ªô ph·ª©c t·∫°p:** O(n¬≤) v·ªõi n l√† s·ªë ƒëi·ªÉm.

**T·ªëi ∆∞u h√≥a:**
- ƒê∆∞·ªùng ch√©o = 0 (kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm ƒë·∫øn ch√≠nh n√≥)
- `if i == j: continue` ƒë·ªÉ b·ªè qua t√≠nh to√°n kh√¥ng c·∫ßn thi·∫øt

---

### 4Ô∏è‚É£ `compute_real_distance_matrix(locations)`

**M·ª•c ƒë√≠ch:** Wrapper function ƒë·ªÉ t√≠nh ma tr·∫≠n kho·∫£ng c√°ch GPS v·ªõi validation v√† logging.

**Input:**
- `locations`: List t·ªça ƒë·ªô GPS (c√≥ th·ªÉ l√† string ho·∫∑c float)

**Output:**
- Ma tr·∫≠n kho·∫£ng c√°ch ƒë√£ validate

**T√≠nh nƒÉng:**
1. **Validate t·ªça ƒë·ªô:** Convert sang float, b·∫Øt l·ªói n·∫øu kh√¥ng h·ª£p l·ªá
2. **Logging:** In ra console ƒë·ªÉ debug
3. **Sample distances:** Hi·ªÉn th·ªã m·ªôt s·ªë kho·∫£ng c√°ch m·∫´u

**V√≠ d·ª• output:**
```
S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p Haversine cho 50 ƒëi·ªÉm

M·ªôt s·ªë kho·∫£ng c√°ch m·∫´u:
T·ª´ ƒëi·ªÉm 0 ƒë·∫øn 1: 1.16 km
T·ª´ ƒëi·ªÉm 0 ƒë·∫øn 2: 2.34 km
T·ª´ ƒëi·ªÉm 1 ƒë·∫øn 2: 1.89 km
```

**C√¢u h·ªèi th·∫ßy c√≥ th·ªÉ h·ªèi:**
- **Q: T·∫°i sao c·∫ßn validate?**
  - A: D·ªØ li·ªáu t·ª´ CSV c√≥ th·ªÉ b·ªã l·ªói (null, string, ngo√†i ph·∫°m vi). Validate s·ªõm ƒë·ªÉ tr√°nh l·ªói khi gi·∫£i.

---

### 5Ô∏è‚É£ `solve_cvrp_with_config()` - H√ÄM CORE NH·∫§T

**M·ª•c ƒë√≠ch:** Gi·∫£i b√†i to√°n CVRP v·ªõi c·∫•u h√¨nh c·ª• th·ªÉ s·ª≠ d·ª•ng th∆∞ vi·ªán OR-Tools.

**Input Parameters:**
- `distance_matrix`: Ma tr·∫≠n kho·∫£ng c√°ch
- `demands`: Danh s√°ch nhu c·∫ßu m·ªói ƒëi·ªÉm
- `vehicle_count`: S·ªë xe s·ª≠ d·ª•ng
- `vehicle_capacity`: T·∫£i tr·ªçng t·ªëi ƒëa m·ªói xe
- `time_limit_s`: Th·ªùi gian gi·ªõi h·∫°n (gi√¢y)
- `strategy`: Chi·∫øn l∆∞·ª£c t√¨m nghi·ªám ban ƒë·∫ßu

**C√°c b∆∞·ªõc gi·∫£i:**

#### **B∆∞·ªõc 1: T·∫°o Data Structure**
```python
data = {
    "distance_matrix": [[0, 10, 15], [10, 0, 20], ...],
    "demands": [0, 5, 10, 8, ...],  # Depot c√≥ demand = 0
    "vehicle_capacities": [100, 100, 100, ...],
    "num_vehicles": 5,
    "depot": 0  # ƒêi·ªÉm xu·∫•t ph√°t v√† k·∫øt th√∫c
}
```

#### **B∆∞·ªõc 2: T·∫°o Routing Model**
```python
manager = pywrapcp.RoutingIndexManager(
    len(distance_matrix),  # S·ªë ƒëi·ªÉm
    num_vehicles,          # S·ªë xe
    depot                  # Depot index
)
routing = pywrapcp.RoutingModel(manager)
```

**`RoutingIndexManager`:** Qu·∫£n l√Ω √°nh x·∫° gi·ªØa:
- **Node Index:** Ch·ªâ s·ªë ƒëi·ªÉm trong d·ªØ li·ªáu (0, 1, 2, ...)
- **Routing Index:** Ch·ªâ s·ªë trong m√¥ h√¨nh OR-Tools (kh√°c nhau do m·ªói xe c√≥ start/end ri√™ng)

#### **B∆∞·ªõc 3: ƒê·ªãnh nghƒ©a Distance Callback**
```python
def dist_cb(from_index, to_index):
    from_node = manager.IndexToNode(from_index)
    to_node = manager.IndexToNode(to_index)
    return distance_matrix[from_node][to_node]

routing.SetArcCostEvaluatorOfAllVehicles(
    routing.RegisterTransitCallback(dist_cb)
)
```

**Gi·∫£i th√≠ch:**
- OR-Tools g·ªçi `dist_cb()` m·ªói khi c·∫ßn t√≠nh chi ph√≠ di chuy·ªÉn t·ª´ ƒëi·ªÉm n√†y sang ƒëi·ªÉm kh√°c
- `RegisterTransitCallback()`: ƒêƒÉng k√Ω h√†m callback v·ªõi solver
- `SetArcCostEvaluator`: Thi·∫øt l·∫≠p h√†m n√†y l√†m h√†m t√≠nh chi ph√≠ cho t·∫•t c·∫£ c√°c xe

#### **B∆∞·ªõc 4: ƒê·ªãnh nghƒ©a Demand Callback & Capacity Constraint**
```python
def demand_cb(from_index):
    node = manager.IndexToNode(from_index)
    return demands[node]

demand_cb_idx = routing.RegisterUnaryTransitCallback(demand_cb)

routing.AddDimensionWithVehicleCapacity(
    demand_cb_idx,           # Callback t√≠nh demand
    0,                       # Slack (ƒë·ªô tr·ªÖ cho ph√©p) = 0
    vehicle_capacities,      # T·∫£i tr·ªçng t·ªëi ƒëa m·ªói xe
    True,                    # Start cumul to zero (b·∫Øt ƒë·∫ßu t·ª´ 0)
    "Capacity"               # T√™n dimension
)
```

**Gi·∫£i th√≠ch Dimension:**
- **Dimension** trong OR-Tools l√† m·ªôt r√†ng bu·ªôc t√≠ch l≈©y (cumulative constraint)
- V√≠ d·ª•: Xe xu·∫•t ph√°t v·ªõi t·∫£i = 0, gh√© ƒëi·ªÉm 1 (demand=5) ‚Üí t·∫£i=5, gh√© ƒëi·ªÉm 2 (demand=8) ‚Üí t·∫£i=13
- N·∫øu t·∫£i > capacity ‚Üí vi ph·∫°m constraint ‚Üí nghi·ªám kh√¥ng h·ª£p l·ªá

#### **B∆∞·ªõc 5: C·∫•u h√¨nh Search Parameters**
```python
search_params = pywrapcp.DefaultRoutingSearchParameters()
search_params.first_solution_strategy = strategy
search_params.time_limit.seconds = time_limit_s
```

**C√°c chi·∫øn l∆∞·ª£c ph·ªï bi·∫øn:**

| Strategy | M√¥ t·∫£ | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|----------|-------|---------|------------|
| `PATH_CHEAPEST_ARC` | Ch·ªçn c·∫°nh r·∫ª nh·∫•t ti·∫øp theo | Nhanh, t·ªët cho b√†i nh·ªè | C√≥ th·ªÉ b·ªã local optimum |
| `PARALLEL_CHEAPEST_INSERTION` | Ch√®n song song ƒëi·ªÉm r·∫ª nh·∫•t v√†o nhi·ªÅu route | C√¢n b·∫±ng t·∫£i gi·ªØa c√°c xe | Ch·∫≠m h∆°n PATH_CHEAPEST |
| `LOCAL_CHEAPEST_INSERTION` | Ch√®n ƒëi·ªÉm v√†o route hi·ªán t·∫°i r·∫ª nh·∫•t | T·ªëi ∆∞u local | Kh√¥ng ƒë·ªìng ƒë·ªÅu gi·ªØa c√°c xe |
| `GLOBAL_CHEAPEST_ARC` | T√¨m c·∫°nh r·∫ª nh·∫•t trong to√†n b·ªô | Nghi·ªám t·ªët h∆°n | R·∫•t ch·∫≠m v·ªõi b√†i l·ªõn |

#### **B∆∞·ªõc 6: Gi·∫£i v√† Tr√≠ch xu·∫•t Solution**
```python
solution = routing.SolveWithParameters(search_params)

if not solution:
    return None  # Kh√¥ng t√¨m ƒë∆∞·ª£c nghi·ªám

routes = []
for vehicle_id in range(num_vehicles):
    index = routing.Start(vehicle_id)  # B·∫Øt ƒë·∫ßu t·ª´ depot
    route = []
    
    while not routing.IsEnd(index):
        node = manager.IndexToNode(index)
        route.append(node)
        index = solution.Value(routing.NextVar(index))  # ƒêi·ªÉm ti·∫øp theo
    
    route.append(0)  # Quay v·ªÅ depot
    
    # Ch·ªâ l∆∞u route c√≥ √≠t nh·∫•t 1 ƒëi·ªÉm giao h√†ng
    if len(route) > 2:  # [0, ƒëi·ªÉm, 0]
        routes.append(route)
```

**Logic l·ªçc route:**
- Route ch·ªâ c√≥ `[0, 0]` = xe kh√¥ng ƒëi ‚Üí b·ªè qua
- Route c√≥ `[0, 5, 8, 0]` = xe ƒëi 2 ƒëi·ªÉm ‚Üí gi·ªØ l·∫°i

**C√¢u h·ªèi th·∫ßy c√≥ th·ªÉ h·ªèi:**
- **Q: T·∫°i sao c·∫ßn l·ªçc route r·ªóng?**
  - A: OR-Tools lu√¥n t·∫°o ƒë·ªß s·ªë xe theo input, nh∆∞ng kh√¥ng ph·∫£i xe n√†o c≈©ng c·∫ßn d√πng. L·ªçc gi√∫p k·∫øt qu·∫£ s·∫°ch v√† t·ªëi ∆∞u s·ªë xe th·ª±c t·∫ø.

- **Q: Time limit ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?**
  - A: OR-Tools ch·∫°y trong th·ªùi gian cho ph√©p, n·∫øu h·∫øt gi·ªù m√† ch∆∞a t√¨m ƒë∆∞·ª£c nghi·ªám t·ªëi ∆∞u, tr·∫£ v·ªÅ nghi·ªám t·ªët nh·∫•t t√¨m ƒë∆∞·ª£c. N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c nghi·ªám n√†o ‚Üí return None.

---

### 6Ô∏è‚É£ `solve_cvrp_api()` - H√ÄM MAIN API

**M·ª•c ƒë√≠ch:** H√†m t·ªïng h·ª£p ƒë·ªçc CSV, x·ª≠ l√Ω d·ªØ li·ªáu, th·ª≠ nhi·ªÅu c·∫•u h√¨nh, v√† tr·∫£ v·ªÅ nghi·ªám t·ªët nh·∫•t.

**Input Parameters:**
- `csv_path`: ƒê∆∞·ªùng d·∫´n file CSV
- `vehicle_count`: S·ªë xe (None = t·ª± ƒë·ªông t√≠nh)
- `vehicle_capacity`: T·∫£i tr·ªçng m·ªói xe
- `time_limit_s`: Th·ªùi gian gi·ªõi h·∫°n

**Quy tr√¨nh x·ª≠ l√Ω:**

#### **B∆∞·ªõc 1: ƒê·ªçc v√† Validate CSV**
```python
df = pd.read_csv(csv_path)
df.columns = [c.strip().lower() for c in df.columns]  # Chu·∫©n h√≥a t√™n c·ªôt

# Ph√°t hi·ªán lo·∫°i d·ªØ li·ªáu
if {"lat", "lng"}.issubset(df.columns):
    data_type = "real"  # GPS th·ª±c t·∫ø
elif {"x", "y"}.issubset(df.columns):
    data_type = "augerat"  # T·ªça ƒë·ªô ph·∫≥ng
else:
    raise ValueError("CSV ph·∫£i c√≥ (x,y) ho·∫∑c (lat,lng)")

if "demand" not in df.columns:
    raise ValueError("CSV thi·∫øu c·ªôt 'demand'")
```

**Format CSV y√™u c·∫ßu:**

**Lo·∫°i 1: GPS th·ª±c t·∫ø**
```csv
lat,lng,demand
21.0285,105.8542,0
21.0345,105.8612,10
21.0412,105.8523,8
```

**Lo·∫°i 2: T·ªça ƒë·ªô ph·∫≥ng (Augerat)**
```csv
x,y,demand
0,0,0
10,20,15
30,40,12
```

#### **B∆∞·ªõc 2: T·ª± ƒë·ªông t√≠nh s·ªë xe**
```python
if not vehicle_count or vehicle_count <= 0:
    vehicle_count = math.ceil(total_demand / vehicle_capacity)
```

**V√≠ d·ª•:**
- T·ªïng demand = 450
- Capacity m·ªói xe = 100
- S·ªë xe t·ªëi thi·ªÉu = ceil(450/100) = 5 xe

**T·∫°i sao d√πng `ceil()`?**
- `ceil(4.1)` = 5 (l√†m tr√≤n l√™n)
- N·∫øu demand = 401, capacity = 100 ‚Üí c·∫ßn 5 xe, kh√¥ng ph·∫£i 4

#### **B∆∞·ªõc 3: T√≠nh ma tr·∫≠n kho·∫£ng c√°ch**
```python
if data_type == "augerat":
    distance_matrix = compute_euclidean_distance_matrix(locations)
else:
    distance_matrix = compute_real_distance_matrix(locations)
```

#### **B∆∞·ªõc 4: Fallback Strategy (C·ªët l√µi c·ªßa ƒë·ªô robust)**

**V·∫•n ƒë·ªÅ:** OR-Tools c√≥ th·ªÉ kh√¥ng t√¨m ƒë∆∞·ª£c nghi·ªám v·ªõi c·∫•u h√¨nh ban ƒë·∫ßu.

**Gi·∫£i ph√°p:** Th·ª≠ nhi·ªÅu c·∫•u h√¨nh kh√°c nhau theo th·ª© t·ª± ∆∞u ti√™n:

```python
attempts = [
    # (s·ªë_xe, time_limit, strategy_name, strategy_enum)
    (5, 60, "PATH_CHEAPEST_ARC", ...),           # Th·ª≠ 1: C·∫•u h√¨nh g·ªëc
    (5, 120, "PATH_CHEAPEST_ARC", ...),          # Th·ª≠ 2: TƒÉng th·ªùi gian x2
    (4, 120, "PARALLEL_CHEAPEST_INSERTION", ...), # Th·ª≠ 3: Gi·∫£m xe, ƒë·ªïi strategy
    (6, 60, "LOCAL_CHEAPEST_INSERTION", ...),    # Th·ª≠ 4: TƒÉng xe
    (5, 180, "GLOBAL_CHEAPEST_ARC", ...),        # Th·ª≠ 5: Th·ªùi gian d√†i + strategy m·∫°nh
]
```

**Logic l·ª±a ch·ªçn nghi·ªám t·ªët nh·∫•t:**
```python
if not best_solution or \
   result['vehicles_used'] < best_solution['vehicles_used'] or \
   (result['vehicles_used'] == best_solution['vehicles_used'] and 
    result['total_distance'] < best_solution['total_distance']):
    best_solution = result
```

**∆Øu ti√™n:**
1. **S·ªë xe √≠t nh·∫•t** (gi·∫£m chi ph√≠ v·∫≠n h√†nh)
2. N·∫øu c√πng s·ªë xe ‚Üí **Qu√£ng ƒë∆∞·ªùng ng·∫Øn nh·∫•t** (gi·∫£m chi ph√≠ xƒÉng)

**D·ª´ng s·ªõm:**
```python
if result['vehicles_used'] <= math.ceil(total_demand / vehicle_capacity):
    print("‚ú® ƒê·∫°t s·ªë xe t·ªëi ∆∞u, d·ª´ng t√¨m ki·∫øm")
    break
```

N·∫øu ƒë√£ ƒë·∫°t s·ªë xe t·ªëi thi·ªÉu l√Ω thuy·∫øt ‚Üí kh√¥ng c·∫ßn th·ª≠ th√™m.

#### **B∆∞·ªõc 5: Tr·∫£ v·ªÅ Response**
```python
return {
    "routes": [[0, 1, 5, 0], [0, 2, 3, 0], ...],  # Danh s√°ch route
    "route_details": [
        {"route": [0,1,5,0], "distance": 1200, "load": 45},
        ...
    ],
    "locations": [[21.028, 105.854], ...],
    "demands": [0, 10, 8, 15, ...],
    "vehicle_capacity": 100,
    "vehicle_count": 5,           # S·ªë xe ban ƒë·∫ßu
    "vehicles_used": 3,           # S·ªë xe th·ª±c t·∫ø d√πng
    "total_demand": 450,
    "total_distance": 12500,      # M√©t
    "type": "real",               # ho·∫∑c "augerat"
    "distance_matrix": [[0, 100, ...], ...],
    "config_used": {
        "vehicle_count": 5,
        "time_limit": 120,
        "strategy": "PATH_CHEAPEST_ARC"
    }
}
```

---

## üéì C√ÇU H·ªéI THUY·∫æT TR√åNH TH∆Ø·ªúNG G·∫∂P

### **1. T·∫°i sao ch·ªçn OR-Tools?**
**Tr·∫£ l·ªùi:**
- ‚úÖ Th∆∞ vi·ªán m√£ ngu·ªìn m·ªü c·ªßa Google
- ‚úÖ T·ªëi ∆∞u h√≥a m·∫°nh m·∫Ω cho VRP, TSP, scheduling
- ‚úÖ H·ªó tr·ª£ nhi·ªÅu constraint (capacity, time window, pickup-delivery)
- ‚úÖ Performance t·ªët v·ªõi b√†i l·ªõn (h√†ng trƒÉm ƒëi·ªÉm)
- ‚úÖ Documentation t·ªët, community l·ªõn

**So s√°nh v·ªõi c√°c ph∆∞∆°ng ph√°p kh√°c:**
| Ph∆∞∆°ng ph√°p | ∆Øu ƒëi·ªÉm | Nh∆∞·ª£c ƒëi·ªÉm |
|-------------|---------|------------|
| OR-Tools | Nhanh, robust, nhi·ªÅu t√≠nh nƒÉng | C√†i ƒë·∫∑t ph·ª©c t·∫°p |
| Genetic Algorithm | D·ªÖ implement | Ch·∫≠m, nghi·ªám kh√¥ng ·ªïn ƒë·ªãnh |
| Simulated Annealing | ƒê∆°n gi·∫£n | Ch·∫≠m, c·∫ßn tune tham s·ªë nhi·ªÅu |
| Brute Force | ƒê∆°n gi·∫£n, nghi·ªám t·ªëi ∆∞u | Ch·ªâ d√πng ƒë∆∞·ª£c v·ªõi <10 ƒëi·ªÉm |

### **2. ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n?**
**Tr·∫£ l·ªùi:**
- CVRP l√† b√†i to√°n **NP-hard** (kh√¥ng c√≥ thu·∫≠t to√°n ƒëa th·ª©c)
- ƒê·ªô ph·ª©c t·∫°p: O(n!) v·ªõi n ƒëi·ªÉm (factorial)
- V√≠ d·ª•: 10 ƒëi·ªÉm = 3,628,800 c√°ch, 15 ƒëi·ªÉm = 1.3 t·ª∑ c√°ch
- OR-Tools d√πng **Branch and Bound + Metaheuristics** ƒë·ªÉ gi·∫£m kh√¥ng gian t√¨m ki·∫øm

### **3. T·∫°i sao c·∫ßn th·ª≠ nhi·ªÅu strategy?**
**Tr·∫£ l·ªùi:**
- Kh√¥ng c√≥ strategy n√†o "t·ªët nh·∫•t" cho m·ªçi b√†i to√°n
- M·ªói strategy c√≥ ƒëi·ªÉm m·∫°nh v·ªõi c·∫•u tr√∫c d·ªØ li·ªáu kh√°c nhau
- Fallback gi√∫p tƒÉng t·ª∑ l·ªá t√¨m ƒë∆∞·ª£c nghi·ªám t·ª´ ~60% l√™n ~95%

### **4. L√†m sao bi·∫øt nghi·ªám t·ªëi ∆∞u?**
**Tr·∫£ l·ªùi:**
- V·ªõi b√†i NP-hard, kh√¥ng c√≥ c√°ch ch·ª©ng minh nghi·ªám l√† t·ªëi ∆∞u tuy·ªát ƒë·ªëi (tr·ª´ khi th·ª≠ h·∫øt)
- OR-Tools cung c·∫•p nghi·ªám **g·∫ßn t·ªëi ∆∞u** (near-optimal)
- So s√°nh v·ªõi **lower bound l√Ω thuy·∫øt**: `ceil(total_demand / capacity)` xe

### **5. X·ª≠ l√Ω khi kh√¥ng t√¨m ƒë∆∞·ª£c nghi·ªám?**
**Tr·∫£ l·ªùi:**
- TƒÉng s·ªë xe
- TƒÉng capacity
- Gi·∫£m demand m·ªôt s·ªë ƒëi·ªÉm (n·∫øu c√≥ th·ªÉ)
- TƒÉng time limit
- Th·ª≠ strategy kh√°c
- Code ƒë√£ implement t·ª± ƒë·ªông fallback

### **6. Scale v·ªõi bao nhi√™u ƒëi·ªÉm?**
**Tr·∫£ l·ªùi:**
| S·ªë ƒëi·ªÉm | Th·ªùi gian | Kh·∫£ nƒÉng |
|---------|-----------|----------|
| <50 | <10s | R·∫•t t·ªët |
| 50-100 | 10-60s | T·ªët |
| 100-200 | 1-5 ph√∫t | Kh·∫£ thi |
| 200-500 | 5-30 ph√∫t | C·∫ßn t·ªëi ∆∞u |
| >500 | >30 ph√∫t | C·∫ßn chia nh·ªè b√†i to√°n |

---

## üî¨ K·ª∏ THU·∫¨T T·ªêI ∆ØU

### **1. T·∫°i sao chuy·ªÉn distance sang int?**
```python
dist[i][j] = int(math.hypot(xi - xj, yi - yj))
```
- OR-Tools t·ªëi ∆∞u h√≥a v·ªõi s·ªë nguy√™n (integer programming)
- Float c√≥ th·ªÉ g√¢y sai s·ªë l√†m tr√≤n t√≠ch l≈©y
- Performance t·ªët h∆°n 20-30%

### **2. T·∫°i sao depot c√≥ demand = 0?**
```python
demands = [0, 10, 8, 15, ...]  # Index 0 = depot
```
- Depot l√† ƒëi·ªÉm xu·∫•t ph√°t, kh√¥ng c√≥ h√†ng c·∫ßn giao
- N·∫øu depot c√≥ demand > 0 ‚Üí vi ph·∫°m logic

### **3. Callback pattern trong OR-Tools**
```python
def dist_cb(from_index, to_index):
    return distance_matrix[from_node][to_node]

routing.RegisterTransitCallback(dist_cb)
```
- OR-Tools g·ªçi callback h√†ng tri·ªáu l·∫ßn trong qu√° tr√¨nh t·ªëi ∆∞u
- Ph·∫£i nhanh, kh√¥ng ƒë∆∞·ª£c c√≥ I/O ho·∫∑c t√≠nh to√°n ph·ª©c t·∫°p

---

## üìà CASE STUDY TH·ª∞C T·∫æ

### **B√†i to√°n: Giao h√†ng TP.HCM - 50 ƒëi·ªÉm**
```
Input:
- 50 ƒëi·ªÉm giao h√†ng
- Total demand: 1,249 ƒë∆°n v·ªã
- Capacity m·ªói xe: 100 ƒë∆°n v·ªã
- S·ªë xe t·ªëi thi·ªÉu l√Ω thuy·∫øt: ceil(1249/100) = 13 xe

Output:
- S·ªë xe th·ª±c t·∫ø: 13 xe
- T·ªïng qu√£ng ƒë∆∞·ªùng: 156.4 km
- Th·ªùi gian gi·∫£i: 8.3 gi√¢y
- Strategy: PATH_CHEAPEST_ARC
```

**Ph√¢n t√≠ch:**
- ƒê·∫°t s·ªë xe t·ªëi thi·ªÉu ‚Üí T·ªëi ∆∞u v·ªÅ capacity
- Qu√£ng ƒë∆∞·ªùng trung b√¨nh m·ªói xe: 12 km
- Hi·ªáu qu·∫£ cao

---

## üõ†Ô∏è DEBUG & TROUBLESHOOTING

### **L·ªói th∆∞·ªùng g·∫∑p:**

**1. "No solution found"**
```
Nguy√™n nh√¢n:
- Capacity qu√° nh·ªè
- S·ªë xe kh√¥ng ƒë·ªß
- Time limit qu√° ng·∫Øn

Gi·∫£i ph√°p:
- TƒÉng capacity
- TƒÉng vehicle_count
- TƒÉng time_limit_s
- Code ƒë√£ t·ª± ƒë·ªông fallback
```

**2. "Invalid coordinates"**
```
Nguy√™n nh√¢n:
- Lat/Lng ngo√†i ph·∫°m vi (-90~90, -180~180)
- Gi√° tr·ªã null ho·∫∑c string

Gi·∫£i ph√°p:
- Validate d·ªØ li·ªáu CSV tr∆∞·ªõc
- D√πng try-except trong compute_real_distance_matrix
```

**3. "Capacity constraint violated"**
```
Nguy√™n nh√¢n:
- Route c√≥ t·ªïng demand > capacity
- Bug trong demand_cb

Gi·∫£i ph√°p:
- Ki·ªÉm tra AddDimensionWithVehicleCapacity
- Verify demands[0] = 0
```

---

## üéØ K·∫æT LU·∫¨N

**ƒêi·ªÉm m·∫°nh c·ªßa h·ªá th·ªëng:**
1. ‚úÖ H·ªó tr·ª£ c·∫£ GPS th·ª±c t·∫ø v√† t·ªça ƒë·ªô ph·∫≥ng
2. ‚úÖ T·ª± ƒë·ªông fallback khi kh√¥ng t√¨m ƒë∆∞·ª£c nghi·ªám
3. ‚úÖ T·ªëi ∆∞u h√≥a s·ªë xe v√† qu√£ng ƒë∆∞·ªùng
4. ‚úÖ Logging chi ti·∫øt ƒë·ªÉ debug
5. ‚úÖ Scale t·ªët v·ªõi b√†i l·ªõn (50-100 ƒëi·ªÉm)

**H∆∞·ªõng ph√°t tri·ªÉn:**
1. üöÄ Th√™m time window constraint (giao h√†ng theo gi·ªù)
2. üöÄ Pickup and delivery (v·ª´a l·∫•y v·ª´a giao)
3. üöÄ Multiple depots (nhi·ªÅu kho xu·∫•t ph√°t)
4. üöÄ Heterogeneous fleet (xe kh√°c capacity)
5. üöÄ Real-time routing (c·∫≠p nh·∫≠t ƒë·ªông khi c√≥ ƒë∆°n m·ªõi)

---

**üìù Ghi ch√∫ cho thuy·∫øt tr√¨nh:**
- Chu·∫©n b·ªã demo v·ªõi file CSV m·∫´u
- In ra console log ƒë·ªÉ th·∫ßy th·∫•y qu√° tr√¨nh
- Gi·∫£i th√≠ch t·ª´ng b∆∞·ªõc v·ªõi visualization (n·∫øu c√≥)
- Nh·∫•n m·∫°nh t√≠nh ·ª©ng d·ª•ng th·ª±c t·∫ø: Logistics, Giao h√†ng, Thu gom r√°c, ...
